
#include <stdio.h>
#include <stdlib.h>
#include "othello_funcs.h"

// Grader: adding missing function skeleton
int computer_move(char board[8][8], char player, unsigned int* row, unsigned int* col){
	
}

void print_othello_board(char board[8][8])
{
        int i, j;
        for(i=0;i<8;i++)
        {
                for(j=0;j<8;j++)
                {
                        printf("%c ",board[i][j]);
                }
                printf("\n");
        }
}

void init_board(char board[8][8])
{
    // Grader: You're making the same mistake here as in tictactoe. If you start
    // at 0 and go up to 8, how many slots have you covered? The reason computer
    // scientists start indices at 0 is so we can say i < length and have the
    // correct number of items. Also, if you are seeing errors in your warmup,
    // take those to a TA before you work on the homework because it will avoid
    // you making the same mistakes again
	for(int i=0; i<9; i++)
	{
		for(int j=0; j<9; j++)
		{
			board[i][j] = '*';
		}
	}
	board[3][3] = 'W';
	board[4][4] = 'W';
	board[4][3] = 'B';
	board[3][4] = 'B';
}	

unsigned int place_left(char board[8][8], char player, unsigned int row, unsigned int col)
{
	int val = 0;
	if(col<6)
	{
		if((board[row][col+1] != '*') && (board[row][col+2] != '*'))
		{
			val = 1;
		}
	}
	return val;
}

unsigned int place_right(char board[8][8], char player, unsigned int row, unsigned int col)
{
	int val = 0;
	if(col>1)
	{
		if((board[row][col-1] != '*') && (board[row][col-2] != '*'))
		{
			val = 1;
		}
	}
	return val;
}

unsigned int place_up(char board[8][8], char player, unsigned int row, unsigned int col)
{
	int val = 0;
	if(row<6)
	{
		if((board[row+1][col] != '*') && (board[row+2][col] != '*'))
		{
			val = 1;
		}
	}
	return val;
}

unsigned int place_down(char board[8][8], char player, unsigned int row, unsigned int col)
{
	int val = 0;
	if(row>1)
	{
		if((board[row-1][col] != '*') && (board[row-2][col] != '*'))
		{
			val = 1;
		}
	}
	return val;
}

unsigned int place_up_right(char board[8][8], char player, unsigned int row, unsigned int col)
{
	int val = 0;
	if((row>1) && (col<6))
	{
		if((board[row+1][col+1] != '*') && (board[row+2][col+2] != '*'))
		{
			val = 1;
		}
	}
	return val;
}

unsigned int place_up_left(char board[8][8], char player, unsigned int row, unsigned int col)
{
	int val = 0;
	if((row>1) && (col>1))
	{
		if((board[row+1][col-1] != '*') && (board[row+2][col-2] != '*'))
		{
			val = 1;
		}
	}
	return val;
}

unsigned int place_down_right(char board[8][8], char player, unsigned int row, unsigned int col)
{
	int val = 0;
	if((row<6) && (col<6))
	{
		if((board[row+1][col+1] != '*') && (board[row+2][col+2] != '*'))
		{
			val = 1;
		}
	}
	return val;
}

unsigned int place_down_left(char board[8][8], char player, unsigned int row, unsigned int col)
{
	int val = 0;
	if((row<6) && (col>1))
	{
		if((board[row+1][col-1] != '*') && (board[row+2][col-2] != '*'))
		{
			val = 1;
		}
	}
	return val;
}

unsigned int place_piece(char board[8][8], char player, unsigned int row, unsigned int col)
{
	int val = 0;
	if(board[row][col]=='*')
	{
		if((place_left(board,player,row,col)==1) 
		|| (place_right(board,player,row,col)==1)
		|| (place_up(board,player,row,col)==1)
		|| (place_down(board,player,row,col)==1)
		|| (place_up_right(board,player,row,col)==1)
		|| (place_up_left(board,player,row,col)==1)
		|| (place_down_right(board,player,row,col)==1)
		|| (place_down_left(board,player,row,col)==1))
		{
			board[row][col] = player;
			//int val2 = flip_pieces(board,row,col);
			val = 1;
		}
		val = 1;
	}
	return val;
}

unsigned int flip_pieces(char board[8][8], unsigned int row, unsigned int col)
{
	return 1;
}

char player_won(char board[8][8])
{
	int white = 0;
	int black = 0;
	for(int i=0; i<9; i++)
	{
		for(int j=0; j<9; j++)
		{
			if(board[i][j] == 'B')
				{
					black = black + 1;
				}
			else if(board[i][j] == 'W')
			{
				white = white + 1;
			}
		}
	}
	if(white == black)
	{
		return '*';
	}
	else if(white > black)
	{
		return 'W';
	}
	else if(black > white)
	{
		return 'B';
	}
}

void play_othello()
{

	char player[2] = {'W','B'};
	int num_tiles[2] = {2,2};
	unsigned int cur_play = 1;
	char board[8][8];
	unsigned int move_num = 0;

	unsigned int num_invalid_moves = 0;
	unsigned int num_valid_moves = 0; // number invalid moves in a row for one player
	unsigned int num_invalid_player = 0; // number of players with invalid moves in a row


	// initialize the game board
	init_board(board);

	// play one move of the game
	do {
		unsigned int row, col;
		unsigned int valid_move;

		print_othello_board(board);

		// get the row input
		do {
			printf("Player %c, in what row (0-7) will you place your next piece? ",
					player[1]); 
			scanf("%u",&row); 

			// if it is an invalid row
			if (row >= 8)
			{
				printf("Player %c, that is not a valid row. Try again.\n",
					player[cur_play]); 
			}
		} while ( row >= 8 );

		// get the col input
		do {
			printf("Player %c, in what column (0-7) will you place your next piece? ",
					player[1]); 
			scanf("%u",&col); 

			// if it is an invalid column
			if (col >= 8)
			{
				printf("Player %c, that is not a valid col. Try again.\n",
					player[cur_play]); 
			}
		} while ( col >= 8 );

		valid_move = place_piece(board, player[cur_play], row, col);

		// if it is not a valid move
		if (valid_move == 0)
		{
			// if they already had an invalid move, switch players
			if (num_invalid_moves > 0)
			{
				num_invalid_moves = 0;
				num_invalid_player++;
			}
			else
			{
				// try again!
				printf("That is not a valid move. Try again.\n"); 
				num_invalid_moves++;
			}

		}
		// flip the tiles
		else
		{
			// add one tile for the tile being placed
			num_tiles[cur_play] += valid_move;

			// switch player
			cur_play = (cur_play + 1)%2;
			num_invalid_moves = 0;
			num_invalid_player = 0;
			num_valid_moves++;
			// subtract flipped tiles from this player's total
			num_tiles[cur_play] -= (valid_move-1);

			// report progress
			printf("White: %u tiles, Black: %u tiles\n", num_tiles[0], num_tiles[1]);
		}

	// exit while there is still space on the board and we haven't had two players with invalid
	// plays in a row
	} while ((num_valid_moves < 64) && (num_invalid_player < 2));

	char winner = player_won(board);
			// check for winning
	if (winner == '*')
	{
		printf("Tie game!\n");
	}
	else
	{
		printf("Congratulations! Player %c won!\n",winner); 
	}

}
