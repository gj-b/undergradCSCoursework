#include <stdio.h>
#include <stdlib.h>
#include "bst.h"
#include "memory.h"

//Prints out all the elements of the tree.
void printing_tree(node* root) 
{ 
    if (root == NULL) 
        return; 
    printing_tree(root->right); 
    printf("\n");
    /*space +=3 
    for (int i = 3; i < space; i++) 
        printf(" "); */
    memory_print(root->data); 
  
    // Process left child 
    printing_tree(root->left); 
} 
/* Global variables
 * By declaring these outside of a function:
 *   Scope: Every function inside of this file may use them. 
 *   		No functions in other files may use them.
 *   Lifetime: They exist for the entire program - they are created
 *		when the program begins and exist until the program
 *		ends.
 */   		

/* This is the tree that holds the available memory. */
bst *avail_mem = NULL;

/* This includes all of the functions for the memory allocator.
 * The last two functions (my_malloc and my_free) are public 
 * functions with prototypes in the header function. The rest of the
 * functions are helper functions only called by my_malloc and 
 * my_free. You must implement these helper functions. If you wish,
 * you may add helper functions we did not define.
 */

/* compact_memory
 *
 * Search through all available memory and attempt to merge memory
 * that is stored next to each other.
 * This uses global variable avail_mem, so it does not need any
 * input parameters. Look at the bst functions and memory functions.
 */
void compact_memory()
{
	 bst *new_tree_by_addr = bst_new(memory_addr_cmp);
  llist *tree_traversed = create_llist(); 
  //modified_bst_inorder_traversal(b,tree_traversed);
  void *item;
  /*for(item = iterate(tree_traversed); item != NULL; item = iterate(NULL))
    addr_bst_insert(new_tree_by_addr,item);*/
  //Not working. This is an L.
}

/* print_available_memory 
 *
 * Print out all available memory in ascending order by size.
 */
void print_memory()
{
	printing_tree(avail_mem->root);
}

/* init_alloc
 *
 * Initializes the data structures. This initializes avail_mem so 
 * that, instead of being a NULL pointer, it points to a valid bst
 * struct whose root pointer is NULL.
 */
void init_alloc()
{
	avail_mem = bst_new(memory_size_cmp);
}

/* my_free
 * 
 * Function that returns the memory chunk whose usable piece starts
 * at that address back to the set of available memory so that it can
 * be reused in a subsequent free call
 */
void my_free(void *address)
{
	unsigned int *address_size = address - 8;
	memory *new_insert = memory_new(address,*address_size);
	memory_print(new_insert);
	bst_insert(avail_mem,new_insert);
}

/* my_malloc
 * 
 * function that finds a piece of available memory that is at least
 * num_bytes size. A pointer to the beginning of the usable piece of
 * that chunk is returned.
 */
void *my_malloc(int num_bytes)
{
	int adj_num_bytes;
	if((num_bytes % 8) == 0)
		adj_num_bytes = num_bytes;
	else
		adj_num_bytes = ((num_bytes + 7) / 8) * 8;
	memory *mem_to_pass = memory_new(0,adj_num_bytes);
	memory* mem_found_in_bst = bst_item_or_successor(avail_mem,mem_to_pass);

	if(mem_found_in_bst->size > (2 * adj_num_bytes))
		return split_memory(mem_found_in_bst,adj_num_bytes);
	else if((adj_num_bytes <= mem_found_in_bst->size) && (2*adj_num_bytes >= mem_found_in_bst->size))
		return mem_found_in_bst;
	else 
	{
		memory *new_chunk = allocate_memory_page();
		void *returned_chunk = split_memory(new_chunk,adj_num_bytes);
		my_free(new_chunk);
		return returned_chunk;
	}
	return NULL;
}


